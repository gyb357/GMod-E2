@name TankTurret FCS V3
@inputs  [Pod Cam]:wirelink [Gun Base]:entity [XZoom ChangeCamPos]:number
@outputs [Target]:entity [ClassText]:string [Lock FOV Latch]:number [CpuOps]:array
@persist [Elevation Depression RotateSpeed Yaw CamOffset CamDist ZoomCount Fall Predict LockOn Hint SetAng]:number [GunHoldKey ClassKey LockOnKey RotateSound LockOnSound LockOffSound]:string
@persist [FindExcOwnEnt ClassMax Magnific Speed MuzzleVel RotateYaw Range Degree ToMeter ToReal DeltaConst FromUnit Gravity FrAera]:number [Inertia]:angle [Own]:entity [Null ClassAry]:array
@persist [Index Active CamMode Zoom Hold ToF LocalVelocity]:number [Class]:string [Chair Driver Entity CenterEnt]:entity [Ranger]:ranger [Pos Delta_Pos VoT GunVel Prediction CamPosition]:vector

    interval(40)
    
if (first() | dupefinished()) {
    # ----- User Interfae ----- #
    # Angle Setting
    Elevation = 20
    Depression = 10
    RotateSpeed = 10
    Yaw = 360
    
    # Cam Setting
    CamOffset = 150
    CamDist = 400
    
    # Zoom Setting
    ZoomCount = 1
    
    # Trajectory Setting
    Fall = 1
    Predict = 1
    LockOn = 1
    
    SetAng = 0
    
    Hint = 0
    
    # Key Setting
    GunHoldKey = "h"
    ClassKey = "t"
    LockOnKey = "g"
    
    # Sound Setting
    RotateSound = "acf_extra/tankfx/turret5.wav"
    LockOnSound = "common/wpn_select.wav"
    LockOffSound = "common/wpn_denyselect.wav"
    
    # ----- Datail Setting ----- #
        FindExcOwnEnt = 0
        ClassMax = 5
        
        Magnific = 80 / ZoomCount
        Speed = SetAng ? RotateSpeed * 0.4 : RotateSpeed
        
        MuzzleVel = 1000
        
    # ----- Don't Touch These ----- #
            RotateYaw = (Yaw / 2)
            
            Range = 50000
            Degree = 10
            
            ToMeter = 39.37
            ToReal = (2 / 3)
            DeltaConst = 1.25
            FromUnit = fromUnit("m", 1) # 52.4934382021
            Gravity = gravity() # 600
            
            FrAera = pi() * (Gun:acfCaliber() / 20)^2
            
            Inertia = shiftL(ang(Gun:inertia()))
            
            Own = owner()
            Null = array(vec(0, 0, 0), ang(0, 0, 0))
            ClassAry = array("null", "player", "prop_physics", "acf_ammo", "baseentity")
            
            rangerFilter(Gun)
            rangerFilter(Base:getConstraints())
            rangerPersist(1)
            
    function void selectClass(Ary:array) {
        Index += Index > ClassMax - 1 ? -ClassMax + 1 : 1
        
        if (changed(Index) & Index) {
            findClearWhiteList()
            
            Class = Index == Ary:count() ? Ary[3, string] : Ary[Index, string]
            ClassText = Ary[Index, string]
            
            findIncludeClass(Class)
            
            if (Hint) {
                Chair:hintDriver(ClassText, 3)
            }
        }
    }
        
    function entity findEntity(CenterPos:vector, CenterDir:vector) {
        if (FindExcOwnEnt) {
            findExcludePlayer(Own)
            findExcludePlayerProps(Own)
        }
        
        findInCone(CenterPos, CenterDir, Range, Degree)
        findSortByDistance(CenterPos)
        
        EntAry = findToArray()
        Entity = EntAry[1, entity]
        
        return Entity
    }
    
    function entity findBase(Ent:entity) {
        Find = 1
        
        while(Find) {
            if(Ent:parent()) {
                Ent = Ent:parent()
                
                if (!Ent:parent() & Ent:isValidPhysics()) {
                    CenterEnt = Ent
                    Find = 0
                }
                elseif (CenterEnt:parent() & !CenterEnt:isValidPhysics()) {
                    Find = 1
                }
            }
            else {
                Find = 0
            }
        }
        
        return CenterEnt
    }
    
    function angle trajectory() {
        Target = Lock ? (Index == 5 ? findBase(Target) : Entity) : (Predict ? Ranger:entity() : Target)
        Pos = Lock ? (Target:isPlayer() ? Target:pos() + vec(0, 0, 32.5) : Target:massCenter()) : Ranger:pos()
        
        Mv0 = Gun:acfMuzzleVel() ? Gun:acfMuzzleVel() * ToMeter : MuzzleVel * ToMeter
        
        if (Mv0) {
            if (Fall) {
                Dx = sqrt((Gun:massCenter():x() - Pos:x())^2 + (Gun:massCenter():y() - Pos:y())^2)
                Dy = Gun:massCenter():z() - Pos:z()
                
                Tangent = (-(Mv0^2)+ sqrt(Mv0^4 - Gravity^2 * Dx^2 + 2 * Dy * Gravity * Mv0^2)) / (Gravity * Dx)
                
                Theta = atan(Tangent)
                
                Drop = vec(0, 0, (Gun:massCenter() + vec(Pos:distance(Gun:massCenter()), 0, 0):rotate(ang(Theta, 0, 0))):z()) - vec(0, 0, Pos:z())
            }
            
            #[
            if (Fall) {
                Dist = toUnit("m", Gun:attachmentPos("muzzle"):distance(Pos))
                ToF = Dist / ((Mv0 / ToMeter) * ToReal)
                Drop = vec(0, 0, (0.5 * Gravity * ToF^2))
            }
            ]#
            
            # DragCoef = FrAera / 10000 / Gun:acfProjectileMass()
            
            if (Predict) {
                if (Target) {
                    if (Target:parent() & !Target:vel()) {
                        VoT = findBase(Target):vel()
                        
                        if (!VoT) {
                            Delta_Pos = $Pos
                            VoT = Delta_Pos * DeltaConst * FromUnit
                        }
                    }
                    else {
                        VoT = Target:vel()
                    }
                }
                else {
                    VoT = Null[1, vector]
                }
                
                if (Fall) {
                    ToF = Dx / (Mv0 * cos(Theta))
                }
                else {
                    Dist = toUnit("m", Gun:attachmentPos("muzzle"):distance(Pos))
                    
                    ToF = Dist / ((Mv0 / ToMeter) * ToReal)
                }
                
                if (Gun:vel()) {
                    GunVel = Gun:vel()
                }
                
                Prediction = (((VoT / ToReal) - GunVel - $GunVel) * ToF) - (0.5 * ($VoT / ToReal) * ToF^2)
            }
        }
        else {
            if (Drop | Prediction) {
                Drop = Prediction = Null[1, vector]
            }
        }
        
        return ((Pos + Drop + Prediction) - Gun:massCenter()):toAngle()
    }
    
    function void lockOn() {
        if (Cam) {
            CamPos = Cam["CamPos", vector]
            CmaDir = Cam["CamDir", vector]
        }
        
        ClassKeyInpt = Driver:keyPressed(ClassKey)
        LockOnKeyInpt = Driver:keyPressed(LockOnKey)
        
        if (changed(ClassKeyInpt) & ClassKeyInpt) {
            selectClass(ClassAry)
        }
        
        if(LockOn & Target & changed(LockOnKeyInpt) & LockOnKeyInpt & Index > 1) {
            findEntity(CamPos, CmaDir)
            
            Lock++
        }
        
        if(Lock > 1 | changed(Class) & Class | Lock & !Target) {
            Lock = 0
        }
    }
    
    function void camControl() {
        if (changed(Active) | changed(ChangeCamPos) & ChangeCamPos) {
            CamMode = !CamMode
            
            CamDistance = CamMode ? 0 : CamDist
            
            Cam["Distance", number] = CamDistance
            Cam["parent", entity] = Base
        }
        
        if (changed(XZoom) & XZoom) {
            Zoom += Zoom > ZoomCount - 1 ? -ZoomCount : 1
            
            FOV = 90 - Zoom * Magnific
        }
        
        CamPosition = Base:pos() + vec(0, 0, CamOffset)
        
        Cam["Position", vector] = CamPosition
        Cam["FOV", number] = FOV
    }
    
    function void turretMovement() {
        EyeAng = Chair:toLocal(Driver:eyeAngles())
        Ranger = rangerOffset(Range, CamPosition, EyeAng:forward())
        
        GunAng = trajectory()
        
        Force = Gun:toWorld(clamp(Gun:toLocal(GunAng), ang(-Speed), ang(Speed)))
        Angle = clamp(Base:toLocal(Force),ang(-Elevation, -RotateYaw, -1), ang(Depression, RotateYaw, 1))
        LocalToGun = Gun:toLocal(Base:toWorld(Angle))
        
        if (SetAng) {
            Gun:propFreeze(1)
            
            Gun:setAng(LocalToGun + Gun:forward():toAngle() * ang(1, 1, 0))
        }
        else {
            Gun:applyAngForce((LocalToGun * 250 - Gun:angVel() * 47) * Inertia)
        }
    }
    
    function void sound() {
        LocalVelocity = Base:toLocal(Gun:angles()):yaw()
        
        soundPitch(1, clamp((abs($LocalVelocity)) * 50, 0, 100))
        
        if (LockOn) {
            if(changed(Lock == 1) & Lock == 1) {
                Driver:soundPlay(2, 1, LockOnSound)
            }
            
            if(changed(Lock == 0) & Lock == 0 & Target) {
                Driver:soundPlay(3, 1, LockOffSound)
            }
        }
    }
    
    Gun:soundPlay(1, 0, RotateSound)
        soundPitch(1, 0)
        
    if (SetAng) {
        Gun:constraintBreak()
        
        Gun:propFreeze(1)
    }
}

    Active = Pod["Active", number]
    
if (changed(Active) & Active) {
    Chair = Pod["Entity", entity]
    Driver = Chair:driver()
    
    FOV = 90
    Zoom = 0
    Index = 1
    Lock = 0
    Hold = 1
    Latch = 1
    
    Class = ClassText = ClassAry[1, string]
}

if (Active) {
    camControl()
    
    HoldKey = Driver:keyPressed(GunHoldKey)
    
    if (changed(HoldKey) & HoldKey) {
        Hold = !Hold
    }
    
    if (!Hold) {
        if (LockOn) {
            lockOn()
        }
        turretMovement()
        
        sound()
    }
    else {
        soundPitch(1, 0)
    }
}
else {
    if (SetAng) {
        Gun:propFreeze(1)
    }
    
    soundPitch(1, 0)
}

    Latch = Hold & !SetAng ? 1 : 0
    
    CpuOps = array(int(cpuUsage() * 1000000), int(ops()))

# Made By RuBid TankTurret V3 V2019.11.20
