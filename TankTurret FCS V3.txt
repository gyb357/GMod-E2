@name TankTurret FCS V3
@inputs  [Pod Cam]:wirelink [Gun Base]:entity [ZoomIn ZoomOut ChangeCamPos]:number
@outputs [Target]:entity [ClassText]:string [Lock Latch FOV]:number [CpuOps]:array
@persist [Elevation Depression RotateSpeed Yaw Follow SetAng CamOffset CamDist ZoomCount Fall Predict LockOn]:number [GunHoldKey ClassKey LockOnKey RotateSound LockOnSound LockOffSound]:string
@persist [FindExcOwnEnt ClassMax ClassHint MagnificMax Speed]:number
@persist [RotateYaw Magnific Range Degree ToMeter ToReal DeltaConst FromUnit Gravity FrAera]:number [Inertia]:angle [Own]:entity [Null ClassAry HintAry]:array
@persist [Index Active CamMode Zoom Hold ToF LocalVelocity]:number [Class]:string [Chair Driver Entity CenterEnt BallsocketBase]:entity [Ranger]:ranger
@persist [Activated Holded PropcoreEnable]:number [GunPos Pos Drop Drag Delta_Pos VoT GunVel Prediction CamPosition LastAimPos]:vector [LastGunAng GunAng HoldAng]:angle

interval(45)

if (first() | dupefinished()) {
    # ----- User Interfae ----- #
    # TurretMovement Setting
    Elevation = 20
    Depression = 10
    RotateSpeed = 10
    Yaw = 360
    
    Follow = 1
    # 0 = No Control
    # 1 = Latch Gun
    # 2 = Stop spin
    # 3 = Rotate at the same angle as the base
    # 4 = Rotate to last gun angle
    # 5 = Rotate to last aim position
    
    SetAng = 0
    
    # Cam Setting
    CamOffset = 150
    CamDist = 400
    
    # Zoom Setting
    ZoomCount = 1
    
    # Trajectory Setting
    Fall = 1
    Predict = 1
    LockOn = 1
    
    # Key Setting
    GunHoldKey = "h"
    ClassKey = "t"
    LockOnKey = "b"
    
    # Sound Setting
    # Sound Index: 1
    RotateSound = "acf_extra/tankfx/turret5.wav"
    
    # Sound Index: 2
    LockOnSound = "common/wpn_select.wav"
    
    # Sound Index: 3
    LockOffSound = "common/wpn_denyselect.wav"
    
    # ----- Datail Setting ----- #
        FindExcOwnEnt = 1
        ClassMax = 5
        ClassHint = 0
        
        MagnificMax = 80
        
        Speed = SetAng ? RotateSpeed * 0.4 : RotateSpeed
        
    # ----- Don't Touch These ----- #
            RotateYaw = (Yaw / 2)
            Magnific = (MagnificMax / ZoomCount)
            
            Range = 50000
            Degree = 10
            
            ToMeter = 39.37
            ToReal = (2 / 3)            # (2 / 3) or 0.667
            DeltaConst = 1.25
            FromUnit = fromUnit("m", 1) # 52.4934382021
            Gravity = gravity()         # 600 Unit, 11.43m/s^2
            
            FrAera = (pi() * (Gun:acfCaliber() / 20)^2) # ACF lua
            
            Inertia = shiftL(ang(Gun:inertia()))
            
            Own = owner()
            Null = array(vec(0, 0, 0), ang(0, 0, 0))
            
            ClassAry = array("null", "player", "prop_physics", "acf_ammo", "baseentity")
            HintAry = array("Propcore needs to be enabled")
            
            rangerFilter(Gun)
            rangerFilter(Base:getConstraints())
            rangerPersist(1)
            
    function void selectClass(Ary:array) {
        Index += Index > ClassMax - 1 ? -ClassMax + 1 : 1
        
        if (changed(Index) & Index) {
            findClearWhiteList()
            
            Class = Index == Ary:count() ? Ary[3, string] : Ary[Index, string]
            ClassText = Ary[Index, string]
            
            findIncludeClass(Class)
            
            if (ClassHint) {
                Chair:hintDriver(ClassText, 3)
            }
        }
    }
        
    function entity findEntity(Posit:vector, Direct:vector) {
        if (FindExcOwnEnt) {
            findExcludePlayer(Own)
            findExcludePlayerProps(Own)
        }
        
        findInCone(Posit, Direct, Range, Degree)
        findSortByDistance(Posit)
        
        EntAry = findToArray()
        Entity = EntAry[1, entity]
        
        return Entity
    }
    
    function entity findBase(Ent:entity) {
        Find = 1
        
        while(Find) {
            if(Ent:parent()) {
                Ent = Ent:parent()
                
                if (!Ent:parent() & Ent:isValidPhysics()) {
                    CenterEnt = Ent
                    Find = 0
                }
                elseif (CenterEnt:parent() & !CenterEnt:isValidPhysics()) {
                    Find = 1
                }
            }
            else {
                Find = 0
            }
        }
        
        return CenterEnt
    }
    
    function angle trajectory() {
        if (!Hold) {
            if (Predict) {
                Target = Lock ? (Index == 5 ? findBase(Target) : Entity) : (Predict ? Ranger:entity() : Target)
            }
            
            Pos = Lock ? (Target:isPlayer() ? Target:pos() + vec(0, 0, 32.5) : Target:massCenter()) : Ranger:pos()
        }
        
        GunPos = Gun:attachmentPos("muzzle")
        
        Dist = toUnit("m", GunPos:distance(Pos))
        
        if (Gun:acfMuzzleVel()) {
            Mv0 = Gun:acfMuzzleVel() * ToMeter
            Mv02 = Gun:acfMuzzleVel() * ToReal
            
            MaxRange = (2 * Mv02^2 * cos(45) * sin(45)) / toUnit("m", Gravity)
            
            if (Fall) {
                Dx = sqrt((GunPos:x() - Pos:x())^2 + (GunPos:y() - Pos:y())^2)
                Dy = GunPos:z() - Pos:z()
                
                Tangent = (-(Mv0^2)+ sqrt(Mv0^4 - Gravity^2 * Dx^2 + 2 * Dy * Gravity * Mv0^2)) / (Gravity * Dx)
                Theta = atan(Tangent)
                
                DragCoef = FrAera / 10000 / Gun:acfProjectileMass()
                
                SubCoef = 1 + ((ToF^2 * (Dist / 25000)) / (Mv0 * DragCoef))
                
                Drag = vec(0, 0, (0.5 * Gravity * ((Mv02 * DragCoef * SubCoef) / cos(Theta)) * ToF^3))
                Drop = vec(0, 0, (GunPos + vec(Pos:distance(GunPos), 0, 0):rotate(ang(Theta, 0, 0))):z()) - vec(0, 0, Pos:z()) + Drag
            }
            
            if (Predict) {
                if (Target) {
                    if (Target:parent() & !Target:vel()) {
                        VoT = findBase(Target):vel()
                        
                        if (!VoT) {
                            Delta_Pos = $Pos
                            VoT = Delta_Pos * DeltaConst * FromUnit
                        }
                    }
                    else {
                        VoT = Target:vel()
                    }
                }
                else {
                    VoT = Null[1, vector]
                }
                
                Pitch = Gun:angles():pitch()
                
                ToF = Fall ? (Dx / (Mv0 * cos(Pitch))) : (Dist / Mv02)
                
                GunVel = Gun:vel()
                
                Prediction = ((VoT - GunVel - $GunVel) * ToF * (1 + (fromUnit("m", Dist) / 60000))) - (0.5 * $VoT * ToF^2)
            }
        }
        
        if (MaxRange < Dist | !Gun:acfMuzzleVel() | isnan(Drop:z()) & isnan(Drag:z())) {
            Drop = Drag = Prediction = Null[1, vector]
            
            soundPitch(1, 150 * Active)
        }
        
        return ((Pos + Drop + Prediction) - Gun:massCenter()):toAngle()
    }
    
    function void lockOn(Cls:number, Lck:number) {
        if (changed(Cls) & Cls) {
            selectClass(ClassAry)
        }
        
        if(LockOn & Target & changed(Lck) & Lck & Index > 1) {
            findEntity(Cam["CamPos", vector], Cam["CamDir", vector])
            
            Lock++
        }
        
        if(Lock > 1 | changed(Class) & Class | Lock & !Target) {
            Lock = 0
        }
    }
    
    function void camControl(CCP:number, Count:number, In:number, Out:number) {
        if (changed(Active) & Active | changed(CCP) & CCP) {
            CamMode = !CamMode
            
            CamDistance = CamMode ? 0 : CamDist
            
            Cam["Distance", number] = CamDistance
            Cam["parent", entity] = Base
        }
        
        if (changed(In) & In) {
            Zoom += Zoom > Count - 1 ? -Count : 1
        }
        elseif (changed(Out) & Out) {
            Zoom -= 0 < Zoom ? 1 : 0
        }
        
        FOV = 90 - Zoom * Magnific
        
        CamPosition = Base:pos() + vec(0, 0, CamOffset)
        
        Cam["Position", vector] = CamPosition
        Cam["FOV", number] = FOV
    }
    
    function void sound(On:string, Off:string) {
        LocalVelocity = Base:toLocal(Gun:angles()):yaw()
        
        soundPitch(1, clamp((abs($LocalVelocity)) * 50, 0, 100))
        
        if (LockOn) {
            if(changed(Lock == 1) & Lock == 1) {
                Driver:soundPlay(3, 1, On)
            }
            elseif (changed(Lock == 0) & Lock == 0 & Target) {
                Driver:soundPlay(4, 1, Off)
            }
        }
    }
    
    Gun:soundPlay(1, 0, RotateSound)
        soundPitch(1, 0)
        
    Follow = clamp(Follow, 0, 5)
    
    #ifndef entity:setPos(vector)
        error(HintAry[1, string])
    #else
        PropcoreEnable = 1
    #endif
    
    if (PropcoreEnable) {
        if (SetAng) {
            Gun:constraintBreak()
            Gun:propFreeze(1)
        }
        
        BallsocketBase = Gun:isConstrainedTo("ADVballsocket")
        
        if (!BallsocketBase) {
            ballsocket(Gun, Null[1, vector], Base, vec(-180, -180, -180), vec(180, 180, 180), Null[1, vector], 1)
        }
        
        Gun:propDrag(0)
        Gun:propInertia(Null[1, vector])
    }
}

    Active = Pod["Active", number]
    
if (changed(Active) & Active) {
    Activated = 1
    
    Chair = Pod["Entity", entity]
    Driver = Chair:driver()
    
    FOV = 90
    Zoom = 0
    Index = 1
    Lock = 0
    Hold = 1
    
    Latch = !SetAng & Follow == 1 ? 1 : 0
    Class = ClassText = ClassAry[1, string]
}

if (Active) {
    camControl(ChangeCamPos, ZoomCount, ZoomIn, ZoomOut)
    
    HoldKey = Driver:keyPressed(GunHoldKey)
    
    if (changed(HoldKey) & HoldKey) {
        Hold = !Hold
    }
    
    if (!Hold) {
        if (LockOn) {
            lockOn(Driver:keyPressed(ClassKey), Driver:keyPressed(LockOnKey))
        }
        
        sound(LockOnSound, LockOffSound)
    }
    else {
        soundPitch(1, 0)
    }
    
    EyeAng = Chair:toLocal(Driver:eyeAngles())
    Ranger = rangerOffset(Range, CamPosition, EyeAng:forward())
    
    GunAng = trajectory()
}
else {
    Hold = 1
}

if (changed(Hold) & Hold) {
    LastGunAng = Gun:angles()
    LastAimPos = Pos
}

if (changed(HoldKey) & HoldKey) {
    Holded = 1
}

if (Hold) {
    soundPitch(1, 0)
    
    switch (Follow) {
        case 2,
            HoldAng = Gun:angles()
            break
        case 3,
            HoldAng = Base:angles():setRoll(0)
            break
        case 4,
            HoldAng = LastGunAng
            break
        case 5,
            HoldAng = Holded & Activated ? (LastAimPos + Drop + Prediction - Gun:massCenter()):toAngle() : Base:angles():setRoll(0)
            break

        default,
            break
    }
    
    GunAng = HoldAng
}

    Force = Gun:toWorld(clamp(Gun:toLocal(GunAng), ang(-Speed), ang(Speed)))
    Angle = clamp(Base:toLocal(Force),ang(-Elevation, -RotateYaw, -1), ang(Depression, RotateYaw, 1))
    LocalToGun = Gun:toLocal(Base:toWorld(Angle))
    
if (SetAng) {
    Gun:propFreeze(PropcoreEnable)
    
    Gun:setAng(LocalToGun + Gun:forward():toAngle() * ang(1, 1, 0))
}
else {
    if (!(Hold & (Follow == 1 | !Follow))) {
        Gun:applyAngForce((LocalToGun * 250 - Gun:angVel() * 47) * Inertia)
    }
}

    Latch = !SetAng & Follow == 1 & Hold ? 1 : 0
    
if (PropcoreEnable) {
    if (!Gun:isWeldedTo() & changed(Latch) & Latch) {
        weld(Gun, Base)
    }
    elseif (Gun:isWeldedTo() & changed(!Latch) & !Latch) {
        Gun:constraintBreak("weld")
    }
}

    CpuOps = array(int(cpuUsage() * 1000000), int(ops()))
    
# Made By RuBid TankTurret V3 V2019.11.30
