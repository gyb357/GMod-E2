@name Afghanit APS V1
@inputs  [Pod]:wirelink [ATGM OptCom]:entity [Guns]:array [Sensor]:entity [Active]
@outputs [Launcher Target]:entity [FindExcludeOwnProp APSAmmo Ready EmitterEffect SoftKill HardKill On CpuUsage Ops] Find Hit
@persist [SpawnDist MissileAngle ShellAngle ReloadTime Ammo Delay HideHolo SoundEffect EmitterEffect FindExcludeOwnProp] [OnOffKey ReloadKey ATGMPropModel ShellPropModel]:string [SoundAry]:array
@persist [Own]:entity [ClassAry]:array
@persist [Driver ATGMProp ShellProp ShellProp2]:entity [Count Timer Detected Find Reloading Used Reload Spawn Sound]
interval(64)

if (first() | dupefinished()) {
    # ----- User Interface ----- #
    SpawnDist    = 70
    MissileAngle = 50
    ShellAngle   = 50
    ReloadTime   = 1
    Ammo         = 10
    Delay        = 1
    
    HideHolo      = 0
    SoundEffect   = 1
    EmitterEffect = 1
    
    FindExcludeOwnProp = 0
    
    OnOffKey  = "t"
    ReloadKey = "r"
    
    ATGMPropModel  = "models/hunter/blocks/cube4x4x4.mdl"
    ShellPropModel = "models/hunter/plates/plate4x4.mdl"
    
    SoundAry  = array("ambient/explosions/explode_1.wav", "ambient/explosions/explode_2.wav", "ambient/explosions/explode_3.wav", "ambient/explosions/explode_4.wav")
    
    # ----- Do Not Touch These ----- #
        Own = owner()
        
        ClassAry = array("acf_missile", "acf_glatgm", "acf_rack", "acf_gun", "acf_opticalcomputer")
        
    function entity findLauncher() {
        function string classCheck() {
            if (ATGM:type() == ClassAry[1, string]) {
                Class = ClassAry[3, string]
            } else {
                if (!OptCom) {
                    Class = ClassAry[4, string]
                } else {
                    Class = ClassAry[5, string]
                }
            }
            
            return Class
        }
        
        if (FindExcludeOwnProp) {
            findExcludePlayerProps(Own)
        } else {
            findIncludePlayerProps(Own)
        }
        findByClass(classCheck())
        findSortByDistance(Launcher:pos())
        Ary      = findToArray()
        Launcher = Ary[1, entity]
        
        return Launcher
    }
    
    function number gunCount() {
        if (Guns) {
            Count++
            Count = Count > Guns:count() ? 1 : Count
        }
        
        return Count
    }
    
    function number delay() {
        if (first() | Delay != 0 & !Timer & !SoftKill& !Reloading | changed(Hit == 1) & Hit == 1) {
            timer("Delay", Delay * 1000)
        }
        
        if (clk("Delay")) {
            Timer = 1
            
            stoptimer("Delay")
        }
        
        if ((changed(ATGMProp) | changed(Hit == 1) & Hit == 1) & !SoftKill) {
            Timer = 0
        }
        
        Ready = Timer
        
        return Ready
    }
    
    function number targetAngle() {
        Target  = !ATGM ? Guns[1, entity] : ATGM
        Angle   = Target == Guns[1, entity] ? ShellAngle : MissileAngle
        Support = Target == Guns[1, entity] ? -Angle * 0.9 : 0
        
        PosToAng  = (Target:pos() - Sensor:pos()):toAngle()
        Ang       = (Target:forward():toAngle())
        
        Yaw   = abs(PosToAng:yaw() - Ang:yaw())
        Pitch = abs(abs(PosToAng:pitch() - Ang:pitch()) - 180)
        
        Yaw_O = abs(abs(Sensor:angles():yaw() - Target:angles():yaw()))
        
        Yaw_M   = Yaw > 180 - Angle - Support & Yaw < 180 + Angle + Support & Yaw_O > 180 - Angle - Support & Yaw_O < 180 + Angle + Support
        Pitch_M = Pitch > 180 - Angle - Support& Pitch < 180 + Angle + Support
        
        Find = Yaw_M & Pitch_M ? 1 : 0
        
        return Find
    }
    
    function number ammo() {
        function number used() {
            Used = clamp(Used + 1, 0, Ammo)
            
            return Used
        }
        
        if (HardKill & (changed(ATGMProp) & ATGMProp) | (changed(Hit == 1)) & Hit == 1) {
            used()
            EmitterEffect = 1
        } else {
            EmitterEffect = 0
        }
        
        return Used
    }
    
    function number reload() {
        if (Used != 0 & APSAmmo < Ammo & !Reloading) {
            CanReload = 1
        } else {
            CanReload = 0
        }
        
        if (changed(Reload) & CanReload) {
            timer("Reload", ReloadTime * 1000)
            
            CanReload = 0
            Reloading = 1
            Ready     = 0
        }
        
        if (clk("Reload")) {
            Reloading = 0
            Used      = 0
            
            stoptimer("Reload")
        }
        
        APSAmmo = clamp(Ammo - Used, 0, Ammo)
        
        return Used
    }
    
    function void standard() {
        if (ATGM:type() == ClassAry[2, string]) {
            FirstDist = toUnit("m", Sensor:pos():distance(Launcher:pos()))
        }
        
        if (ATGM) {
            if (FirstDist > SpawnDist * 2 & !OptCom) {
                SoftKill = 1
                HardKill = 0
            } else {
                SoftKill = 0
                HardKill = 1
            }
        } else {
            SoftKill = 0
            HardKill = 1
        }
    }
    
    function void interceptionATGM(Missile:entity) {
        if (ATGM:type() == ClassAry[1, string]) {
            ATGMPos = ATGM:pos()
        } else {
            if (SoftKill) {
                if (Launcher:type() == ClassAry[5, string]) {
                    ATGMPos = Launcher:pos()
                } elseif (Launcher:type() == ClassAry[4, string]) {
                    ATGMPos = Launcher:pos() + (Launcher:massCenter() - Launcher:pos()):normalized() * 150
                }
            } else {
                ATGMPos = ATGM:pos() + (ATGM:pos() - Launcher:pos()):normalized() * 150
            }
        }
        
        function number detected() {
            Dist              = toUnit("m", Sensor:pos():distance(ATGM:pos()))
            MissileToRackDist = toUnit("m", Launcher:pos():distance(ATGM:pos()))
            
            Detected = changed(ATGM:pos()) & MissileToRackDist > 1 & Dist < SpawnDist ? 1 : 0
            
            return Detected
        }
        
        if (ATGM) {
            Spawn = detected() & Find & APSAmmo != 0 & Ready ? 1 : 0
        } else {
            Spawn             = 0
            Dist              = 0
            MissileToRackDist = 0
            Detected          = 0
            Find              = 0
        }
        
        if (Spawn) {
            if (!ATGMProp) {
                ATGMProp = propSpawn(ATGMPropModel, ATGMPos, ang(0, 0, 0), 1)
                
                ATGMProp:propDraw(0)
                ATGMProp:setMass(50000)
            }
        } else {
            if (!SoftKill & ATGMProp) {
                ATGMProp:propDelete()
            }
        }
        
        if (SoftKill & ATGMProp) {
            timer("Delete", 100)
            
            if (clk("Delete")) {
                ATGMProp:propDelete()
                
                stoptimer("Delete")
            }
        }
    }
    
    function void interceptionShell() {
        function vector spawnPos() {
            GunsToSensorDist = toUnit("m", Sensor:pos():distance(Guns[1, entity]:pos()))
            ShellPos         = Sensor:pos() + Sensor:forward() * GunsToSensorDist * 10 - (Guns[1, entity]:pos() - Guns[1, entity]:attachmentPos("muzzle")):normalized() * GunsToSensorDist
            
            return ShellPos
        }
        
        if (Find & Ready) {
            if (!ShellProp) {
                ShellProp  = propSpawn(ShellPropModel, spawnPos(), Guns[1, entity]:angles() + ang(90, 0, 0), 1)
                ShellProp2 = propSpawn(ShellPropModel, spawnPos() + ShellProp:pos():normalized() * 10, Guns[1, entity]:angles() + ang(90, 0, 0), 1)
                
                ShellProp:propDraw(0)
                ShellProp:setMass(50000)
                
                ShellProp2:propDraw(0)
                ShellProp2:setMass(50000)
            }
            ShellProp:setPos(spawnPos())
        } else {
            ShellProp:propDelete()
            ShellProp2:propDelete()
        }
    }
    
    function void apsEffect() {
        function void randomSound() {
            Sound   = floor(random(1, 5))
            Explode = SoundAry[Sound, string]
        }
        
        Effect = ATGMProp | ShellProp ? 1 : 0
        
        if (changed(Effect == 1) & HardKill & SoundEffect) {
            randomSound()
            
            if (ATGMProp) {
                soundPlay(1, 3, Explode)
            }
        }
        
        if (Effect == 1 & changed(ShellProp:acfPropHealth())) {
            randomSound()
            
            if (ShellProp:acfPropHealth() / ShellProp:acfPropHealthMax() < 0.999) {
                ShellProp:propDelete()
                ShellProp2:propDelete()
                
                Hit = 1
                
                soundPlay(1, 3, Explode)
            } else {
                Hit = 0
            }
        }
    }
    
    function void keyPress() {
        Reload = Driver:keyPressed(ReloadKey)
        OnOff  = Driver:keyPressed(OnOffKey)
        
        if (changed(OnOff) & OnOff) {
            On = !On
        }
        
        if (changed(On)) {
            if (On) {
                hint("Afghanit On", 3)
            } else {
                hint("Afghanit Off", 3)
            }
        }
    }
    
    function void sensorAngle() {
        holoCreate(1)
        holoModel(1, "models/sprops/misc/cones/size_0/cone_6x6.mdl")
        holoScale(1, vec(2, 2, 2))
        holoColor(1, vec(250, 0, 0))
        holoPos(1, Sensor:massCenter() + Sensor:forward() * Sensor:boxSize() * 5)
        holoAng(1, Sensor:forward():toAngle() + ang(90, 0, 0))
        holoAlpha(1, 255 * !HideHolo)
        holoParent(1, Sensor)
    }
    
    sensorAngle()
}

if (changed(Active)) {
    Chair  = Pod["Entity", entity]
    Driver = Chair:driver()
}
    Active = Pod["Active", number]
    
if (Active) {
    keyPress()
}

if (On) {
    findLauncher()
    gunCount()
    targetAngle()
    delay()
    ammo()
    reload()
    standard()
    
    if (ATGM) {
        interceptionATGM(ATGM)
    }
    
    if (Target == Guns[1, entity]) {
        interceptionShell()
    } else {
        ShellProp:propDelete()
        ShellProp2:propDelete()
    }
    
    apsEffect()
} else {
    EmitterEffect = 0
    
    ShellProp:propDelete()
    ShellProp2:propDelete()
}

    CpuUsage = cpuUsage() * 1000000
    Ops      = ops()

# Made By RuBid Afghanit APS V1 V2019.07.31
